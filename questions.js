const questionsData = [
    {
        "question": "Какая структура данных относятся к категории линейных списков?",
        "multiple": false,
        "options": [
            "Множество",
            "Бинарное дерево",
            "Дек",
            "Массив"
        ],
        "correctAnswers": [
            "Дек"
        ]
    },
    {
        "question": "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в лучшем случае?",
        "multiple": true,
        "options": [
            "нотация о (о-малое)",
            "нотация Ω (омега-большое)",
            "нотация Θ (тета)",
            "нотация О (о-большое)"
        ],
        "correctAnswers": [
            "нотация Ω (омега-большое)",
            "нотация Θ (тета)"
        ]
    },
    {
        "question": "Имеется узел АВЛ-дерева, для которого |hl-hr|=0, где hl, hr высота левого и правого поддерева соответственно. В левое поддерево вставляется новый ключ, после этого:",
        "multiple": false,
        "options": [
            "требуется перестройка дерева",
            "требуется перестройка малым правым поворотом",
            "требуется перестройка малым левым поворотом",
            "не требуется перестройка дерева"
        ],
        "correctAnswers": [
            "не требуется перестройка дерева"
        ]
    },
    {
        "question": "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в худшем случае?",
        "multiple": true,
        "options": [
            "нотация ω (омега-малое)",
            "нотация Ω (омега-большое)",
            "нотация О (о-большое)",
            "нотация Θ (тета)"
        ],
        "correctAnswers": [
            "нотация О (о-большое)",
            "нотация Θ (тета)"
        ]
    },
    {
        "question": "Бинарное дерево - это:",
        "multiple": false,
        "options": [
            "дерево, у которого каждый узел содержит до двух различных значений",
            "дерево, элементы которого являются двоичными числами",
            "дерево, у которого каждый узел может содержать до двух дочерних узлов",
            "дерево, у которого каждый узел должен содержать два дочерних узла"
        ],
        "correctAnswers": [
            "дерево, у которого каждый узел может содержать до двух дочерних узлов"
        ]
    },
    {
        "question": "Отличительная особенность алгоритма Бойера-Мура-Хорспула:",
        "multiple": false,
        "options": [
            "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с таблицей префиксов (префикс-функцией)",
            "После каждого неудачного сравнения производится сдвиг образца вправо на количество позиций, равное количеству предшествующих удачных сравнений",
            "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
            "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с эвристикой стоп-символов (\"плохих\" символов)"
        ],
        "correctAnswers": [
            "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с эвристикой стоп-символов (\"плохих\" символов)"
        ]
    },
    {
        "question": "Какое из условий проверяется при определении сбалансированности красно-черного дерева?",
        "multiple": false,
        "options": [
            "Количество красных или черных узлов в левом и правом поддеревьях равны",
            "Высота левого и правого поддерева равны",
            "Любой путь от корня дерева к листу содержит одно и то же число черных узлов",
            "Любой путь от корня дерева к листу содержит одно и то же число красных узлов"
        ],
        "correctAnswers": [
            "Любой путь от корня дерева к листу содержит одно и то же число черных узлов"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в худшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n)",
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(1)"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n)"
        ]
    },
    {
        "question": "Основное требование, предъявляемое к массиву для возможности выполнения двоичного поиска:",
        "multiple": false,
        "options": [
            "Упорядоченность массива",
            "Статический массив",
            "Массив целочисленных значений",
            "Массив небольшого размера"
        ],
        "correctAnswers": [
            "Упорядоченность массива"
        ]
    },
    {
        "question": "Какие отношения между элементами поддерживает структура данных бинарное дерево?",
        "multiple": false,
        "options": [
            "Двоичные",
            "Иерархические",
            "Сложные",
            "Бинарные"
        ],
        "correctAnswers": [
            "Иерархические"
        ]
    },
    {
        "question": "Какие существуют случаи в анализе алгоритма:",
        "multiple": false,
        "options": [
            "Простой и быстрый",
            "Общий, частный и оптимальный",
            "Эффективный, неэффективный и оптимальный",
            "Наилучший, средний и наихудший"
        ],
        "correctAnswers": [
            "Наилучший, средний и наихудший"
        ]
    },
    {
        "question": "В основе алгоритма Рабина-Карпа используется:",
        "multiple": false,
        "options": [
            "Префикс-функция",
            "Эвристика стоп-символов (\"плохих\" символов)",
            "Эвристика \"хороших\" суффиксов",
            "Хеш-функция"
        ],
        "correctAnswers": [
            "Хеш-функция"
        ]
    },
    {
        "question": "Имеется идеально сбалансированное двоичное дерево (не являющееся деревом поиска), содержащее целые числа. Симметричный просмотр дерева (слева-направо, in-oder обход) даёт следующий результат: 2, 4, 6, 8, 10, 12, 14. Какой узел является корнем дерева?",
        "multiple": false,
        "options": [
            "8",
            "6",
            "2",
            "10"
        ],
        "correctAnswers": [
            "8"
        ]
    },
    {
        "question": "В какой последовательности располагаются вершины дерева при прямом обходе (preorder):",
        "multiple": false,
        "options": [
            "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15",
            "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15",
            "8, 9, 4, 10, 11, 5, 2, 12, 13, 6, 14, 15, 7, 3, 1",
            "8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7, 15"
        ],
        "correctAnswers": [
            "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15"
        ]
    },
    {
        "question": "Что означает утверждение, что алгоритм X асимптотически более эффективен, чем алгоритм Y?",
        "multiple": false,
        "options": [
            "X будет лучшим выбором для любых входных данных до некоторого граничного значения",
            "X будет лучшим выбором для любых входных данных, начиная с некоторого граничного значения",
            "X будет лучшим выбором для любых входных данных",
            "X будет лучшим выбором для любых входных данных, кроме очень больших"
        ],
        "correctAnswers": [
            "X будет лучшим выбором для любых входных данных, начиная с некоторого граничного значения"
        ]
    },
    {
        "question": "Что будет выведено при прямом обходе дерева?",
        "multiple": false,
        "options": [
            "a b c d e f",
            "a b d e c f",
            "d b e a f c",
            "b d e c f 1"
        ],
        "correctAnswers": [
            "a b d e c f"
        ]
    },
    {
        "question": "Укажите асимптотическую сложность операции удаления элемента в позиции i из массива размером n:",
        "multiple": false,
        "options": [
            "O(n)",
            "O(logn)",
            "O(1)",
            "O(n^2)"
        ],
        "correctAnswers": [
            "O(n)"
        ]
    },
    {
        "question": "Высота (глубина) бинарного дерева поиска из N узлов в наилучшем случае определяется по формуле:",
        "multiple": false,
        "options": [
            "h=log2(N+1)",
            "h=N",
            "h=log2(N+1)-1",
            "h=log2N"
        ],
        "correctAnswers": [
            "h=log2(N+1)"
        ]
    },
    {
        "question": "В основе алгоритма Бойера-Мура-Хорспула используется:",
        "multiple": false,
        "options": [
            "Эвристика стоп-символов (\"плохих\" символов)",
            "Префикс-функция",
            "Эвристика \"хороших\" суффиксов",
            "Хеш-таблица"
        ],
        "correctAnswers": [
            "Эвристика стоп-символов (\"плохих\" символов)"
        ]
    },
    {
        "question": "Для структуры данных стек справедливо:",
        "multiple": false,
        "options": [
            "Линейный список с одной вершиной",
            "Доступ возможен к произвольному элементу",
            "Удаление (выборка) возможно произвольного элемента",
            "Линейный список с двумя вершинами"
        ],
        "correctAnswers": [
            "Линейный список с одной вершиной"
        ]
    },
    {
        "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=О(g(n)):",
        "multiple": false,
        "options": [
            "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)",
            "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
            "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
            "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно"
        ],
        "correctAnswers": [
            "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)"
        ]
    },
    {
        "question": "Укажите асимптотическую сложность операции удаления элемента, на который имеется указатель (например, ptr), из двунаправленного списка размером n:",
        "multiple": false,
        "options": [
            "O(n^2)",
            "O(logn)",
            "O(1)",
            "O(n)"
        ],
        "correctAnswers": [
            "O(1)"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска по бинарному дереву поиска (binary search tree, BST) в лучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n)",
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(n log(n))",
            "f(n)=ϴ(log(n))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(log(n))"
        ]
    },
    {
        "question": "Какое количество узлов в полном бинарном дереве высотой 4?",
        "multiple": false,
        "options": [
            "48",
            "32",
            "64",
            "31"
        ],
        "correctAnswers": [
            "31"
        ]
    },
    {
        "question": "Отличительная особенность алгоритма Бойера-Мура:",
        "multiple": false,
        "options": [
            "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
            "Производится посимвольное сравнение образца с текстом при равенстве хешей",
            "Сравнение символов производится начиная с конца текста",
            "Сравнение символов производится начиная с конца образца;"
        ],
        "correctAnswers": [
            "Сравнение символов производится начиная с конца образца;"
        ]
    },
    {
        "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:int count = 1;     while (count < n) {   count = count * 2;  / * Последовательность шагов программы с временной сложностью O (1) * /}",
        "multiple": false,
        "options": [
            "квадратичная",
            "экспоненциальная",
            "линейная",
            "логарифмическая"
        ],
        "correctAnswers": [
            "логарифмическая"
        ]
    },
    {
        "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=Ω(g(n)) и сравнением двух действительных чисел а и b:",
        "multiple": false,
        "options": [
            "а ≥ b",
            "а ≤ b",
            "а >b",
            "а = b"
        ],
        "correctAnswers": [
            "а ≥ b"
        ]
    },
    {
        "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов поиска:",
        "multiple": false,
        "options": [
            "Операции сравнения данных",
            "Операции сравнения и перемещения данных",
            "Операции перемещения данных",
            "Все имеющиеся операции в алгоритме"
        ],
        "correctAnswers": [
            "Операции сравнения и перемещения данных"
        ]
    },
    {
        "question": "Пример какой структуры данных изображён на рисунке?",
        "multiple": false,
        "options": [
            "кольцо",
            "стек",
            "очередь",
            "дек"
        ],
        "correctAnswers": [
            "дек"
        ]
    },
    {
        "question": "Какой из видов линейных списков лучше использовать при реализации задачи по проверке баланса круглых скобок (соответствие открывающей и закрывающей скобок: (()()) – баланс)?",
        "multiple": false,
        "options": [
            "Очередь",
            "Линейный двусвязный список",
            "Линейный односвязный список",
            "Стек"
        ],
        "correctAnswers": [
            "Стек"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма интерполяционного поиска в худшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n log(n))",
            "f(n)=ϴ(n)",
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(log(log(n))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n)"
        ]
    },
    {
        "question": "Для структуры данных очередь справедливо:",
        "multiple": false,
        "options": [
            "Удаление элемента возможно из начала и из конца списка",
            "Вставка нового элемента возможна в начало и в конец списка",
            "Доступ возможен к произвольному элементу",
            "Удаление элемента возможно с одной из сторон списка"
        ],
        "correctAnswers": [
            "Удаление элемента возможно с одной из сторон списка"
        ]
    },
    {
        "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=О(g(n)) и сравнением двух действительных чисел а и b:",
        "multiple": false,
        "options": [
            "а = b",
            "а ≥ b",
            "а < b",
            "а ≤ b"
        ],
        "correctAnswers": [
            "а ≤ b"
        ]
    },
    {
        "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:   for(int i = 0; i < n; i++)      for(int j = 0; j < n; j++)           cout<<“hello”;",
        "multiple": false,
        "options": [
            "константная",
            "экспоненциальная",
            "линейная",
            "квадратичная"
        ],
        "correctAnswers": [
            "квадратичная"
        ]
    },
    {
        "question": "Выберите все характеристики хеш-функции, используемой в алгоритме поиска Рабина-Карпа:",
        "multiple": true,
        "options": [
            "кольцевой (\"скользящий\", \"летящий\")",
            "полиномиальный хеш",
            "отсутствие коллизий",
            "модульная арифметика"
        ],
        "correctAnswers": [
            "кольцевой (\"скользящий\", \"летящий\")",
            "полиномиальный хеш",
            "модульная арифметика"
        ]
    },
    {
        "question": "Для структуры данных дек справедливо:",
        "multiple": false,
        "options": [
            "Линейный список с произвольным количеством вершин",
            "Вставка нового элемента возможна только в начало списка",
            "Удаление элемента возможно из произвольной позиции",
            "Вставка нового элемента возможна в начало или в конец списка"
        ],
        "correctAnswers": [
            "Вставка нового элемента возможна в начало или в конец списка"
        ]
    },
    {
        "question": "Какой формулой определяется максимальное количество узлов в бинарном дереве высотой k (у корня высота 0)?",
        "multiple": false,
        "options": [
            "2^k + 1",
            "2^(k-1) + 1",
            "2^k - 1",
            "2^(k+1) - 1"
        ],
        "correctAnswers": [
            "2^(k+1) - 1"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма бинарного (двоичного) поиска в худшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n)",
            "f(n)=ϴ(n log(n))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(log(n))"
        ]
    },
    {
        "question": "Перед выполнением какой операции в линейном двусвязном списке необходимо выполнить два \"подготовительных\" оператора:...q->prev->next=q->next;q->next->prev=q->prev;...(q - указатель на некрайний узел списка).",
        "multiple": false,
        "options": [
            "Обмен значениями двух узлов по указателю q",
            "Вставка нового узла после элемента, ссылку на который хранит указатель q",
            "Удаление узла по указателю q",
            "Вставка нового узла по указателю q"
        ],
        "correctAnswers": [
            "Удаление узла по указателю q"
        ]
    },
    {
        "question": "Когда достигается максимальная эффективность алгоритма Бойера-Мура?",
        "multiple": false,
        "options": [
            "Если образец длинный, а мощность алфавита достаточно низка",
            "Если образец длинный, а мощность алфавита достаточно велика",
            "Если образец короткий, а мощность алфавита достаточно низка",
            "Если образец короткий, а мощность алфавита достаточно велика"
        ],
        "correctAnswers": [
            "Если образец длинный, а мощность алфавита достаточно велика"
        ]
    },
    {
        "question": "Укажите свойство, характеризующее структуру данных Дек:",
        "multiple": false,
        "options": [
            "Удаление элемента возможно из заданной позиции",
            "Вставка нового элемента возможна в заданную позицию",
            "Обладает двумя первыми элементами",
            "Линейный список с заданным количеством узлов"
        ],
        "correctAnswers": [
            "Вставка нового элемента возможна в заданную позицию"
        ]
    },
    {
        "question": "В каком типе деревьев лист не должен содержать значение?",
        "multiple": false,
        "options": [
            "В-дерево",
            "красно-черное дерево",
            "АВЛ-дерево",
            "бинарное дерево поиска"
        ],
        "correctAnswers": [
            "В-дерево"
        ]
    },
    {
        "question": "Что измеряется для оценки временной (вычислительной) сложности алгоритма:",
        "multiple": false,
        "options": [
            "Зависимость количества итераций от размера обрабатываемых данных",
            "Зависимость количества выполняемых основных операций от объёма входа",
            "Зависимость количества выполняемых основных операторов от размера доступной памяти",
            "Зависимость объема требуемой памяти от размера обрабатываемых данных"
        ],
        "correctAnswers": [
            "Зависимость количества выполняемых основных операций от объёма входа"
        ]
    },
    {
        "question": "Временная (вычислительная) сложность алгоритма определяется объёмом входа n. Этот параметр в частном случае может определяться:",
        "multiple": false,
        "options": [
            "Размером занимаемой входными данными памяти",
            "Количеством определённых подпрограмм",
            "Количеством основных операций",
            "Размером обрабатываемого массива или файла"
        ],
        "correctAnswers": [
            "Размером обрабатываемого массива или файла"
        ]
    },
    {
        "question": "Линейные списки находят применение в технологии:",
        "multiple": false,
        "options": [
            "организации доменов Active Directory",
            "распределённых систем блокчейн",
            "символьной адресации узлов DNS",
            "реляционных баз данных"
        ],
        "correctAnswers": [
            "распределённых систем блокчейн"
        ]
    },
    {
        "question": "В основе алгоритма Кнута-Морриса-Пратта используется:",
        "multiple": false,
        "options": [
            "Эвристика \"хороших\" суффиксов",
            "Эвристика стоп-символов (\"плохих\" символов)",
            "Префикс-функция",
            "Хеш-таблица"
        ],
        "correctAnswers": [
            "Префикс-функция"
        ]
    },
    {
        "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=ϴ(g(n)):",
        "multiple": false,
        "options": [
            "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
            "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
            "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
            "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)"
        ],
        "correctAnswers": [
            "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно"
        ]
    },
    {
        "question": "Для каких узлов необходимо проверить коэффициент балансировки (баланс-фактор) после добавления узла в АВЛ-дерево?",
        "multiple": false,
        "options": [
            "Для всех предков нового узла вплоть до корня дерева",
            "Только для нового добавленного узла",
            "Для всех узлов дерева",
            "Для родителя нового узла"
        ],
        "correctAnswers": [
            "Для всех предков нового узла вплоть до корня дерева"
        ]
    },
    {
        "question": "Дисциплина обслуживания (порядок выполнения операций) стека:",
        "multiple": false,
        "options": [
            "OFIL",
            "FIFO",
            "LOFI",
            "LIFO"
        ],
        "correctAnswers": [
            "LIFO"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Бойера-Мура в лучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n)",
            "f(n, m)=ϴ(log(n+m))",
            "f(n, m)=ϴ(log(n*m))",
            "f(n, m)=ϴ(log(n/m))"
        ],
        "correctAnswers": [
            "f(n, m)=ϴ(log(n/m))"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма линейного (последовательного) поиска в худшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n log(n))",
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n2)",
            "f(n)=ϴ(n)"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n)"
        ]
    },
    {
        "question": "Какие из перечисленных АВЛ-деревьев не требуют проведения перестройки?",
        "multiple": false,
        "options": [
            "2, 3, 4",
            "1, 3, 4",
            "1, 2, 3",
            "1, 2, 4"
        ],
        "correctAnswers": [
            "1, 2, 4"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Кнута-Морриса-Пратта в лучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n2)",
            "f(n)=ϴ(n)",
            "f(n, m)=ϴ(log(n*m))",
            "f(n, m)=ϴ(n+m)"
        ],
        "correctAnswers": [
            "f(n, m)=ϴ(n+m)"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма прямого поиска в тексте по образцу в худшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n)",
            "f(n, m)=ϴ(log(n+m))",
            "f(n)=ϴ(n2)",
            "f(n, m)=ϴ(log(n*m))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n2)"
        ]
    },
    {
        "question": "Когда один алгоритм считается эффективнее другого:",
        "multiple": false,
        "options": [
            "Если его вычислительная сложность в наихудшем случае имеет более низкий порядок роста",
            "Если его вычислительная сложность в наихудшем случае имеет более высокий порядок роста",
            "Если его вычислительная сложность в наилучшем случае имеет более низкий порядок роста",
            "Если его вычислительная сложность в наилучшем случае имеет более высокий порядок роста"
        ],
        "correctAnswers": [
            "Если его вычислительная сложность в наихудшем случае имеет более низкий порядок роста"
        ]
    },
    {
        "question": "При каком значении баланс-фактора b (т.е. разницы высот правого и левого поддеревьев) необходимо выполнить перестройку АВЛ-дерева?",
        "multiple": false,
        "options": [
            "|b| = 0",
            "|b| = 2",
            "|b| = 1",
            "|b| > 2"
        ],
        "correctAnswers": [
            "|b| = 2"
        ]
    },
    {
        "question": "Имеется описание структуры узла линейного односвязного списка:struct Tnode {    Tdata data;    XXXX next;}Какое определение должно быть у экземпляра этой структуры на месте XXXX?",
        "multiple": false,
        "options": [
            "struct",
            "void",
            "Tnode",
            "*Tnode"
        ],
        "correctAnswers": [
            "*Tnode"
        ]
    },
    {
        "question": "Какое из перечисленных АВЛ-деревьев требует балансировки?",
        "multiple": false,
        "options": [
            "1",
            "3",
            "2",
            "4"
        ],
        "correctAnswers": [
            "3"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в лучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(1)",
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n log(n))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(1)"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма вставки ключа в бинарное дерево поиска в наилучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=О(n)",
            "f(n)=О(log(n))",
            "f(n)=О(1)",
            "f(n)=О(nlog(n))"
        ],
        "correctAnswers": [
            "f(n)=О(log(n))"
        ]
    },
    {
        "question": "Зачем нужен заглавный элемент в двусвязном кольцевом списке?",
        "multiple": false,
        "options": [
            "Чтобы иметь указатель на текущий элемент",
            "Чтобы указать на первый элемент",
            "Для связи последнего и первого элемента",
            "Для удаления пустых указателей"
        ],
        "correctAnswers": [
            "Чтобы указать на первый элемент"
        ]
    },
    {
        "question": "Дисциплина обслуживания (порядок выполнения операций) очереди:",
        "multiple": false,
        "options": [
            "LIFO",
            "LOFI",
            "OFIL",
            "FIFO"
        ],
        "correctAnswers": [
            "FIFO"
        ]
    },
    {
        "question": "Структура данных, работа с элементами которой организована по принципу FIFO (первый пришел - первый ушел), - это:",
        "multiple": false,
        "options": [
            "дек",
            "стек",
            "массив",
            "очередь"
        ],
        "correctAnswers": [
            "очередь"
        ]
    },
    {
        "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов сортировки:",
        "multiple": false,
        "options": [
            "Все имеющиеся операции в алгоритме",
            "Операции перемещения данных",
            "Операции сравнения данных",
            "Операции сравнения и перемещения данных"
        ],
        "correctAnswers": [
            "Операции сравнения и перемещения данных"
        ]
    },
    {
        "question": "Величина сдвига при поиске образца в тексте определяется наибольшим значением из трёх, вычисленных, соответственно, по трём правилам (эвристикам) в алгоритме:",
        "multiple": false,
        "options": [
            "Бойера-Мура-Хорспула",
            "Кнута-Морриса-Прата",
            "Бойера-Мура с турбосдвигом",
            "Бойера-Мура"
        ],
        "correctAnswers": [
            "Бойера-Мура"
        ]
    },
    {
        "question": "Суть алгоритма сортировки методом Шелла заключается в:",
        "multiple": false,
        "options": [
            "Отдельной сортировке частей массива относительно опорного элемента",
            "Чередовании проходов по сортируемому массиву слева-направо и справа-налево",
            "Попарным сравнением элементов массива с целью выбора наименьшего",
            "Отдельной сортировке элементов, отстоящих друг от друга на расстоянии h, уменьшающемся на каждом проходе массива до значения 1"
        ],
        "correctAnswers": [
            "Отдельной сортировке элементов, отстоящих друг от друга на расстоянии h, уменьшающемся на каждом проходе массива до значения 1"
        ]
    },
    {
        "question": "В чем смысл анализа алгоритма:",
        "multiple": false,
        "options": [
            "Обеспечить безопасность данных",
            "Предсказать требуемые для его выполнения вычислительные ресурсы",
            "Определить требования к интерфейсу",
            "Предсказать форматы структур данных и внешние связи между ними"
        ],
        "correctAnswers": [
            "Предсказать требуемые для его выполнения вычислительные ресурсы"
        ]
    },
    {
        "question": "Алгоритмы сортировки выбором, обменом и вставкой называются простыми в смысле их:",
        "multiple": false,
        "options": [
            "ёмкостной сложности",
            "временной сложности",
            "интеллектуальной сложности",
            "вычислительной сложности"
        ],
        "correctAnswers": [
            "временной сложности"
        ]
    },
    {
        "question": "Что обеспечивает метод пробирования \"двойное хеширование\" при вставке элемента в хеш-таблицу, разрешающей коллизии по методу открытого адреса?",
        "multiple": false,
        "options": [
            "Вычисление смещения, зависящее от значения ключа",
            "Эффективное рехеширование",
            "Вычисление смещения, не зависящее от значения ключа",
            "Длину первичного кластера"
        ],
        "correctAnswers": [
            "Вычисление смещения, зависящее от значения ключа"
        ]
    },
    {
        "question": "Известно, что при построении хеш-таблиц возможно появление коллизий. Коллизия это такая ситуация, когда:",
        "multiple": false,
        "options": [
            "Определение области поиска производится с помощью учета знака разности между ключом и текущим значением элемента",
            "Для разных ключей хэш-функция может принимать одно и тоже значение h(ki) = h(kj)",
            "Способ нахождения промежуточных значений определяется величиной по имеющемуся дискретному набору значений",
            "Для одинаковых ключей хэш-функция может принимать разные значения h(ki) ≠ h(kj)"
        ],
        "correctAnswers": [
            "Для разных ключей хэш-функция может принимать одно и тоже значение h(ki) = h(kj)"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма Дейкстры в графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E –количество ребер:",
        "multiple": false,
        "options": [
            "f(n)=О(V)",
            "f(n)=О(E*log(V))",
            "f(n)=О(E)",
            "f(n)=О(V^2)"
        ],
        "correctAnswers": [
            "f(n)=О(E*log(V))"
        ]
    },
    {
        "question": "Какая функция реализует линейную рекурсию:",
        "multiple": false,
        "options": [
            "Содержит один вызов самой себя",
            "Содержит линейную функцию",
            "Количество вызовов самой себя определяется линейной функцией",
            "Содержит несколько вызовов самой себя"
        ],
        "correctAnswers": [
            "Содержит один вызов самой себя"
        ]
    },
    {
        "question": "Какой код будет получен из входной строки символов ABCCCDDDDD при использовании алгоритма Хаффмана?",
        "multiple": false,
        "options": [
            "110 111 10 10 10 0 0 0 0 0 0",
            "1 2 3 3 3 4 4 4 4 4",
            "A1 B1 C3 D5",
            "00 01 10 10 10 11 11 11 11 11"
        ],
        "correctAnswers": [
            "110 111 10 10 10 0 0 0 0 0 0"
        ]
    },
    {
        "question": "Какая идея положена в основу построения алгоритма методом \"жадного алгоритма\"",
        "multiple": false,
        "options": [
            "Осуществляется разбиение задачи на неперекрывающиеся подзадачи",
            "На каждом этапе осуществляется выбор решения, которое может не быть оптимальным в данный момент, но в результате решение станет оптимальным",
            "Осуществляется разбиение задачи на перекрывающиеся подзадачи",
            "На каждом этапе осуществляется выбор решения, которое кажется оптимальным в данный момент"
        ],
        "correctAnswers": [
            "На каждом этапе осуществляется выбор решения, которое кажется оптимальным в данный момент"
        ]
    },
    {
        "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 44, 11, 7, 8, 42. Какова высота этого дерева?",
        "multiple": false,
        "options": [
            "4",
            "3",
            "5",
            "2"
        ],
        "correctAnswers": [
            "4"
        ]
    },
    {
        "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов(1,3,5,2,4), (1,3,5,2,4), (1,3,2,5,4), (1,3,2,4,5),(1,3,2,4,5), (1,2,3,4,5), (1,2,3,4,5), (1,2,3,4,5)",
        "multiple": false,
        "options": [
            "Простой вставки",
            "Простого выбора",
            "Простого обмена",
            "Шелла"
        ],
        "correctAnswers": [
            "Простого обмена"
        ]
    },
    {
        "question": "Что будет результатом применения алгоритма RLE (\"групповое кодирование\") к сжатию текста ААААААААААААААААААAВВВВВАААВВВВВBBС?",
        "multiple": false,
        "options": [
            "(22)A(12)B(1)C",
            "ABАВC(19,5,3,7,1)",
            "19A5B3A7B1C",
            "ABC(19,5,3,7,1)"
        ],
        "correctAnswers": [
            "(22)A(12)B(1)C"
        ]
    },
    {
        "question": "Нелинейными называются структуры данных, в которых:",
        "multiple": false,
        "options": [
            "связи между элементами не зависят от упорядоченности значений элементов",
            "связи между элементами не зависят от линейной упорядоченности элементов",
            "связи между элементами зависят от выполнения определенного условия",
            "связи между элементами не зависят от выполнения какого-либо условия"
        ],
        "correctAnswers": [
            "связи между элементами не зависят от линейной упорядоченности элементов"
        ]
    },
    {
        "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов(3,1,4,2,5), (3,1,2,4,5), (2,1,3,4,5), (1,2,3,4,5)",
        "multiple": false,
        "options": [
            "Простого обмена",
            "Простой вставки",
            "Шелла",
            "Простого выбора"
        ],
        "correctAnswers": [
            "Шелла",
            "Простого обмена"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в ширину в неориентированном графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E –количество ребер:",
        "multiple": false,
        "options": [
            "f(n)=О(V2)",
            "f(n)=О(V log(E))",
            "f(n)=О(V+E)",
            "f(n)=О(V)"
        ],
        "correctAnswers": [
            "f(n)=О(V+E)"
        ]
    },
    {
        "question": "Какой код будет получен из входной строки символов 1111223444 при использовании алгоритма группового кодирования RLE (Run Length Encoding)?",
        "multiple": false,
        "options": [
            "0 0 0 0 01 01 10 11 11 11",
            "1-4-2-2-3-1-4-3",
            "41 22 13 34",
            "4 1 2 2 1 3 3 4"
        ],
        "correctAnswers": [
            "4 1 2 2 1 3 3 4"
        ]
    },
    {
        "question": "К недостаткам рекурсивного метода можно отнести:",
        "multiple": true,
        "options": [
            "возможность переполнения стековой памяти программного процесса",
            "расход времени на выделение и очистку стекового кадра в памяти",
            "меньшая точность результата вычислений",
            "возможность переполнения динамически распределяемой памяти программного процесса"
        ],
        "correctAnswers": [
            "возможность переполнения стековой памяти программного процесса",
            "расход времени на выделение и очистку стекового кадра в памяти"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в среднем и наилучшем случаях?",
        "multiple": false,
        "options": [
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n log(n))",
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(n)"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n log(n))"
        ]
    },
    {
        "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:   for(int i = n/2; i < n; i++)      for(int j = 1; j < n; j = j*2) {       /* Последовательность шагов программы с временной сложностью O(1) */      }",
        "multiple": false,
        "options": [
            "логарифмическая",
            "квадратичная",
            "линейная",
            "линейно-логарифмическая"
        ],
        "correctAnswers": [
            "линейно-логарифмическая"
        ]
    },
    {
        "question": "Сложность рекурсивного алгоритма вычисления N-ого числа Фибоначчи можно снизить с O(2^n) до О(n), т.е. оптимизировать процесс вычисления, если сохранять промежуточные значения решения подзадач. Какой метод построения алгоритма (алгоритмическая стратегия) здесь задействован?",
        "multiple": false,
        "options": [
            "Динамическое программирование",
            "Метод рекурсии",
            "Разделяй и властвуй",
            "\"Жадный\" алгоритм"
        ],
        "correctAnswers": [
            "Динамическое программирование"
        ]
    },
    {
        "question": "Как определить, что функция реализует каскадную (множественную) рекурсию:",
        "multiple": false,
        "options": [
            "Функция вызывает несколько внешних функций по любой из всех возможных ветвей алгоритма",
            "Функция вызывает последовательно несколько внешних функций",
            "Функция вызывает параллельно несколько внешних функций",
            "Вызов функции по любой из всех возможных ветвей алгоритма встречается более одного раза"
        ],
        "correctAnswers": [
            "Вызов функции по любой из всех возможных ветвей алгоритма встречается более одного раза"
        ]
    },
    {
        "question": "Имеется линейный односвязный список из n (n>2) узлов. Структура узла списка:struct Tnode {    Tdata data;    Tnode* next;}L - указатель на его начало. Укажите группу операторов, которые обеспечат корректное удаление двух узлов из начала списка L:",
        "multiple": false,
        "options": [
            "q1=L; delete q1; q2=q1; L=q2->next; delete q2;",
            "q1=L; L=L->next->next; q2=L; delete q1; delete q2;",
            "q1=L; q2=L; L=q2->next; delete q1;delete q2;",
            "q1=L; q2=L->next; L=L->next->next; delete q1;delete q2;"
        ],
        "correctAnswers": [
            "q1=L; q2=L->next; L=L->next->next; delete q1;delete q2;"
        ]
    },
    {
        "question": "Что проверяет условие Айверсона в алгоритме сортировки методом простого обмена:",
        "multiple": false,
        "options": [
            "Количество элементов в неупорядоченной части массива",
            "Не пуст ли массив",
            "Наличие обменов в текущем проходе по массиву",
            "Наличие сравнений в текущем проходе по массиву"
        ],
        "correctAnswers": [
            "Наличие обменов в текущем проходе по массиву"
        ]
    },
    {
        "question": "В результате применения алгоритма RLE был получен сжатый текст 9A-4ВCAВ7C. Какой текст был сжат этим алгоритмом?",
        "multiple": false,
        "options": [
            "AAAAAAAAABACBCCCCCCC",
            "(9)A-BCAB(7)C",
            "AAAAAAAAABCABCCCCCCC",
            "AAAAAAAAABCABBCABBCABBCABCCCCCCC"
        ],
        "correctAnswers": [
            "AAAAAAAAABCABCCCCCCC"
        ]
    },
    {
        "question": "В результате применения алгоритма RLE был получен сжатый текст 9A-4ВCAВ7C. Какой коэффициент сжатия этого текста обеспечил алгоритм RLE?",
        "multiple": false,
        "options": [
            "0,5",
            "1,7",
            "2",
            "1,5"
        ],
        "correctAnswers": [
            "2"
        ]
    },
    {
        "question": "Префиксный код в теории кодирования - это:",
        "multiple": false,
        "options": [
            "кодовое слово фиксированной длины, с которого может начинаться другое кодовое слово",
            "кодовое слово переменной длины, с которого может начинаться другое кодовое слово",
            "кодовое слово фиксированной длины, с которого не может начинаться другое кодовое слово",
            "кодовое слово переменной длины, с которого не может начинаться другое кодовое слово того же кода"
        ],
        "correctAnswers": [
            "кодовое слово переменной длины, с которого не может начинаться другое кодовое слово того же кода"
        ]
    },
    {
        "question": "Когда алгоритм считается корректным:",
        "multiple": false,
        "options": [
            "Когда для каждого ввода результатом его работы является корректный вывод",
            "Когда для каждого вывода результатом его работы является корректный ввод",
            "Когда для одного определённого ввода результатом его работы является корректный вывод",
            "Когда он может выдать ответ, отличный от ожидаемого"
        ],
        "correctAnswers": [
            "Когда для каждого ввода результатом его работы является корректный вывод"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом Шелла в наилучшем случае?",
        "multiple": false,
        "options": [
            "f(n)=О(n)",
            "f(n)=О(n^2)",
            "f(n)=О(n log(n))",
            "f(n)=О(log(n))"
        ],
        "correctAnswers": [
            "f(n)=О(n log(n))",
            "f(n)=О(n)"
        ]
    },
    {
        "question": "Алгоритм Флойда-Уоршала - это:",
        "multiple": false,
        "options": [
            "Алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе",
            "Алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных",
            "Алгоритм поиска заданного пользователем количества путей между двумя вершинами во взвешенном графе",
            "Алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа"
        ],
        "correctAnswers": [
            "Алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа"
        ]
    },
    {
        "question": "Что предусматривает метод динамического программирования?",
        "multiple": false,
        "options": [
            "Переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач",
            "Запоминание результатов решения тех подзадач, которые могут повторно использоваться",
            "Получение решения исходно задачи путем комбинирования рекурсивных решений подзадач",
            "Выбор локально-оптимального решения каждой подзадачи для достижения оптимального конечного результата"
        ],
        "correctAnswers": [
            "Запоминание результатов решения тех подзадач, которые могут повторно использоваться"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простой вставки в наилучшем случае:",
        "multiple": false,
        "options": [
            "f(n)=О(n)",
            "f(n)=О(log(n))",
            "f(n)=О(n log(n))",
            "f(n)=О(n^2)"
        ],
        "correctAnswers": [
            "f(n)=О(n)"
        ]
    },
    {
        "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 15, 18, 10, 11, 7, 8, 17, 16. Из дерева удалили узел с ключом 18. Узел с каким значением был выбран замещающим?",
        "multiple": false,
        "options": [
            "18",
            "16",
            "15",
            "17"
        ],
        "correctAnswers": [
            "17"
        ]
    },
    {
        "question": "Как называется алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных?",
        "multiple": false,
        "options": [
            "Алгоритм Крускала",
            "Алгоритм Дейкстры",
            "Алгоритм Йена",
            "Алгоритм Флойда-Уоршала"
        ],
        "correctAnswers": [
            "Алгоритм Дейкстры"
        ]
    },
    {
        "question": "Чем может быть вызвано переполнение стека при выполнении рекурсивной функции с небольшой глубиной рекурсии:",
        "multiple": false,
        "options": [
            "Неправильно оформленным выводом результата",
            "Неправильно сформулированным условием завершения рекурсии",
            "Неправильным выполнением вызова функции",
            "Неправильно оформленным блоком входа в рекурсию"
        ],
        "correctAnswers": [
            "Неправильно сформулированным условием завершения рекурсии"
        ]
    },
    {
        "question": "Что определяет структура данных:",
        "multiple": false,
        "options": [
            "Множество данных",
            "Множество данных и отношений между ними",
            "Множество данных и множество операций над ними",
            "Множество отношений между данными в форме операций над ними"
        ],
        "correctAnswers": [
            "Множество данных и множество операций над ними",
            "Множество данных и отношений между ними"
        ]
    },
    {
        "question": "Дано описание функции:int f(int x) { return (x == 0) ? 1 : x * f(x-1); }Данная функция вычисляет:",
        "multiple": false,
        "options": [
            "факториал числа n",
            "n-ое простое число",
            "n-ое число Фибоначчи",
            "степень числа n"
        ],
        "correctAnswers": [
            "факториал числа n"
        ]
    },
    {
        "question": "Алгоритм обхода графа - это:",
        "multiple": false,
        "options": [
            "Алгоритм, указывающий несколько путей обработки одних и тех же входных данных, без какого-либо уточнения, какой именно вариант будет выбран",
            "Алгоритм, устанавливающий переход от одной его вершины к другой с целью нахождения кратчайшего пути",
            "Алгоритм, устанавливающий переход от одной его вершины к другой в поисках свойств связей этих вершин",
            "Алгоритм, устанавливающий движение от начальной вершины в определенном направлении (по определенному пути) до тех пор, пока не будет достигнут конец пути или заданная вершина"
        ],
        "correctAnswers": [
            "Алгоритм, устанавливающий движение от начальной вершины в определенном направлении (по определенному пути) до тех пор, пока не будет достигнут конец пути или заданная вершина"
        ]
    },
    {
        "question": "Структура хранения, обеспечивающая прямой доступ к каждому элементу данных, т.е. время доступа к значению О(1):",
        "multiple": false,
        "options": [
            "сетевая",
            "иерархическая",
            "списочная",
            "векторная"
        ],
        "correctAnswers": [
            "векторная"
        ]
    },
    {
        "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 11, 7, 8, 44, 42. В это дерево был вставлен узел с ключом 6. В какое поддерево и какого узла был вставлен узел?",
        "multiple": false,
        "options": [
            "В левое поддерево узла 11",
            "В левое поддерево узла 7",
            "В левое поддерево узла 13",
            "В левое поддерево узла 42"
        ],
        "correctAnswers": [
            "В левое поддерево узла 7"
        ]
    },
    {
        "question": "Имеется следующее оптимальное кодовое дерево (ОКД):Выберите исходную строку, которая была закодирована в битовый код 111 0 0 10 10 0 110 0 10 0 по алгоритму Хаффмана с использованием приведенного ОКД:",
        "multiple": false,
        "options": [
            "DDDDDCCCBA",
            "BDDCCDADCD",
            "ABDCDCDCDD",
            "ABCCCDDDDD"
        ],
        "correctAnswers": [
            "BDDCCDADCD"
        ]
    },
    {
        "question": "Как называется алгоритм, который напрямую или через другие вспомогательные алгоритмы вызывает сам себя:",
        "multiple": false,
        "options": [
            "Разветвляющийся",
            "Циклический",
            "Рекурсивный",
            "Линейный"
        ],
        "correctAnswers": [
            "Рекурсивный"
        ]
    },
    {
        "question": "Росту первичного кластера в хеш-таблице с открытым адресом способствует:",
        "multiple": false,
        "options": [
            "Смещение и размер таблицы имеют общие множители",
            "Размер таблицы определен как простое число и смещение простое число",
            "Для большого количества ключей хеш-функция сформировала один и тот же индекс",
            "Ключи равномерно распределены по таблице"
        ],
        "correctAnswers": [
            "Смещение и размер таблицы имеют общие множители"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простого обмена (с условием Айверсона) в наилучшем случае:",
        "multiple": false,
        "options": [
            "f(n)=О(n log(n))",
            "f(n)=О(log(n))",
            "f(n)=О(n)",
            "f(n)=О(n^2)"
        ],
        "correctAnswers": [
            "f(n)=О(n)"
        ]
    },
    {
        "question": "К графу на рисунке 1 применен алгоритм обхода в глубину. Какое из остовных деревьев соответствует обходу в глубину с вершины 3?",
        "multiple": false,
        "options": [
            "2",
            "5",
            "3",
            "4"
        ],
        "correctAnswers": [
            "4"
        ]
    },
    {
        "question": "Что помещается в стек рекурсивных вызовов при вызове рекурсивной функции?",
        "multiple": false,
        "options": [
            "Значения всех переменных функции при текущем вызове для возврата в точку вызова",
            "Описание всех переменных функции при текущем вызове",
            "Имена локальных переменных и параметров функции",
            "Адрес точки возврата, значения всех переменных функции текущего вызова"
        ],
        "correctAnswers": [
            "Адрес точки возврата, значения всех переменных функции текущего вызова",
            "Имена локальных переменных и параметров функции"
        ]
    },
    {
        "question": "Чему равна сумма степеней вершин графа?",
        "multiple": false,
        "options": [
            "Числу его ребер",
            "Удвоенному числу его ребер",
            "Сумме веса ребер",
            "Удвоенному весу ребер"
        ],
        "correctAnswers": [
            "Удвоенному числу его ребер"
        ]
    },
    {
        "question": "Имеется бинарное дерево поиска, содержащее целые числа от 1 до 7. Каким будет результат вывода при обратном обходе дерева (postoder):",
        "multiple": false,
        "options": [
            "4, 1, 2, 3, 5, 6, 7",
            "1, 2, 3, 4, 5, 6, 7",
            "4, 1, 5, 2, 6, 3, 7",
            "7, 6, 5, 4, 3, 2, 1"
        ],
        "correctAnswers": [
            "7, 6, 5, 4, 3, 2, 1"
        ]
    },
    {
        "question": "Каков главный недостаток хеш-таблиц?",
        "multiple": false,
        "options": [
            "В отказе на повторное хеширование",
            "В трудоёмкой функции хеширования",
            "Фиксированный размер, при неизвестном окончательном числе элементов",
            "Фиксированное число элементов, располагающихся в таблице"
        ],
        "correctAnswers": [
            "Фиксированный размер, при неизвестном окончательном числе элементов"
        ]
    },
    {
        "question": "Выберите код, являющийся результатом сжатия по методу скользящего окна текста \"abacabacabadaca\". Примечание: кавычки ограничивают текст и не кодируются.",
        "multiple": false,
        "options": [
            "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(2,1,пусто)",
            "(0,0,a)(0,0,b)(2,1,c)(4,4,d)(2,1,c)(2,1,пусто)",
            "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(4,1,пусто)",
            "(0,0,a)(0,0,b)(2,1,c)(3,7,d)(2,1,c)(2,1,пусто)"
        ],
        "correctAnswers": [
            "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(2,1,пусто)"
        ]
    },
    {
        "question": "Диапазон допустимых значений простого типа данных определяется разрядностью отдельного значения этого типа. В перечне примеров найдите неправильный вариант:",
        "multiple": false,
        "options": [
            "char – занимает 1 байт, следовательно, имеет диапазон от –128 до +127",
            "short int – занимает 2 байта, следовательно, имеет диапазон от –32 768 до +32 767",
            "long int – занимает 4 байта, следовательно, имеет диапазон от –2 147 483 648 до +2 147 483 647",
            "int – занимает 4 байта, следовательно, имеет диапазон от –2 148 483 647 до +2 147 483 647"
        ],
        "correctAnswers": [
            "int – занимает 4 байта, следовательно, имеет диапазон от –2 148 483 647 до +2 147 483 647",
            "long int – занимает 4 байта, следовательно, имеет диапазон от –2 147 483 648 до +2 147 483 647"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки шейкерным методом (с условием Айверсона) в наихудшем случае:",
        "multiple": false,
        "options": [
            "f(n)=О(log(n))",
            "f(n)=О(n^2)",
            "f(n)=О(n log(n))",
            "f(n)=О(n^3)"
        ],
        "correctAnswers": [
            "f(n)=О(n^2)"
        ]
    },
    {
        "question": "Какой алгоритм из перечисленных не основан на жадном подходе?",
        "multiple": false,
        "options": [
            "Алгоритм нахождения кратчайшего пути Беллмана-Форда",
            "Алгоритм нахождения кратчайшего пути Дейкстры",
            "Алгоритм кодирования Хаффмана",
            "Алгоритм построения минимального остовного дерева Крускала"
        ],
        "correctAnswers": [
            "Алгоритм нахождения кратчайшего пути Беллмана-Форда"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки слиянием (Mergesort) в среднем и наихудшем случаях:",
        "multiple": false,
        "options": [
            "f(n)=ϴ(n)",
            "f(n)=ϴ(n^2)",
            "f(n)=ϴ(log(n))",
            "f(n)=ϴ(n log(n))"
        ],
        "correctAnswers": [
            "f(n)=ϴ(n log(n))"
        ]
    },
    {
        "question": "Что хранит матрица смежности графа?",
        "multiple": false,
        "options": [
            "Список ребер и их направление",
            "Список вершин",
            "Длину пути между вершинами графа",
            "Только направления ребер"
        ],
        "correctAnswers": [
            "Список ребер и их направление"
        ]
    },
    {
        "question": "Система байтового кодирования символов ASCII кодирует символы входной последовательности кодами:",
        "multiple": false,
        "options": [
            "переменной длины до одного байта",
            "фиксированной длины в один байт",
            "хеш-кодами",
            "переменной длины свыше одного байта"
        ],
        "correctAnswers": [
            "фиксированной длины в один байт"
        ]
    },
    {
        "question": "Для динамической структуры данных (переменной) справедливо утверждение:",
        "multiple": false,
        "options": [
            "создается на этапе компиляции кода и размер не может быть изменен во время выполнения программы",
            "создается на этапе выполнения программы и размер может быть изменен на этапе выполнения",
            "создается на этапе компиляции кода и размер может быть изменен во время выполнения программы",
            "создается на этапе выполнения программы и размер не может быть изменен на этапе выполнения"
        ],
        "correctAnswers": [
            "создается на этапе выполнения программы и размер может быть изменен на этапе выполнения"
        ]
    },
    {
        "question": "Как называется алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа?",
        "multiple": false,
        "options": [
            "Алгоритм Флойда-Уоршала",
            "Алгоритм Дейкстры",
            "Алгоритм Крускала",
            "Алгоритм Прима"
        ],
        "correctAnswers": [
            "Алгоритм Флойда-Уоршала"
        ]
    },
    {
        "question": "Дана следующая рекурсивная функция:int fib(int n) {if (n <2) { return 1; }else { return fib(n - 2) + fib(n - 1); }}Какова высота дерева рекурсии при вызове fib(5)?",
        "multiple": false,
        "options": [
            "7",
            "4",
            "3",
            "5"
        ],
        "correctAnswers": [
            "7",
            "5"
        ]
    },
    {
        "question": "Метод сортировки считается устойчивым, если:",
        "multiple": false,
        "options": [
            "время доступа к значению константное",
            "относительное расположение элементов с равными ключами всегда изменяется",
            "начальная отсортированность массива не важна",
            "относительное расположение элементов с равными ключами не изменяется"
        ],
        "correctAnswers": [
            "время доступа к значению константное",
            "относительное расположение элементов с равными ключами не изменяется"
        ]
    },
    {
        "question": "Свойство алгоритма, обеспечивающее возможность его использования для решения множества однотипных задач (применимость к различным наборам входных данных), называется:",
        "multiple": false,
        "options": [
            "Массовость",
            "Результативность",
            "Дискретность",
            "Завершаемость"
        ],
        "correctAnswers": [
            "Массовость"
        ]
    },
    {
        "question": "Какой алгоритм сортировки из перечисленных ниже будет самым эффективным на уже отсортированном массиве?",
        "multiple": false,
        "options": [
            "вставками",
            "пирамидальная",
            "быстрая сортировка",
            "слиянием"
        ],
        "correctAnswers": [
            "вставками"
        ]
    },
    {
        "question": "Что будет результатом применения алгоритма RLE - \"Групповое кодирование\" к сжатию текста ААААААААААААААААААВCAВCAСCCCCC?",
        "multiple": false,
        "options": [
            "A(18)BCA(2)C(6)",
            "18A-6ВCAВCA6C",
            "18A-2BCA6C",
            "A18ABCABC6C"
        ],
        "correctAnswers": [
            "A(18)BCA(2)C(6)"
        ]
    },
    {
        "question": "Понятие \"глубина рекурсии\" для рекурсивной функции определяет:",
        "multiple": false,
        "options": [
            "Наибольшее одновременное количество рекурсивных обращений функции",
            "Количество операторов вызова функции в самой функции",
            "Наибольшее количество операторов в рекурсивной функции",
            "Количество внешних вызовов функции в программе"
        ],
        "correctAnswers": [
            "Наибольшее одновременное количество рекурсивных обращений функции",
            "Количество внешних вызовов функции в программе"
        ]
    },
    {
        "question": "Какой алгоритм реализует стратегию \"разделяй и властвуй\" (divide and conquer approach)?",
        "multiple": false,
        "options": [
            "алгоритм Дейкстры",
            "алгоритм Бойера-Мура",
            "алгоритм быстрой сортировки Quick-sort",
            "алгоритм Крускала"
        ],
        "correctAnswers": [
            "алгоритм Дейкстры",
            "алгоритм Бойера-Мура"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма пирамидальной сортировки (Heapsort) в среднем случае?",
        "multiple": false,
        "options": [
            "f(n)=О(n log(n))",
            "f(n)=О(n)",
            "f(n)=О(n^2)",
            "f(n)=О(log(n))"
        ],
        "correctAnswers": [
            "f(n)=О(n log(n))"
        ]
    },
    {
        "question": "Есть ли ошибка в коде функции f, которая осуществляет получение ссылки на последний узел линейного односвязного списка со структурой узла?struct Tnode{ Tdata data; Tnode* next;};Tnode *f(Tnode *L) {    Tnode *q=L;    while(q) { q=q->next; }    return q;}",
        "multiple": false,
        "options": [
            "Ошибка в записи оператора q=q->next",
            "Ошибки нет",
            "Ошибка в условии while (q) - должно быть while (q->next)",
            "Ошибка в записи оператора Tnode *q=L - должно быть Tnode q=L"
        ],
        "correctAnswers": [
            "Ошибка в условии while (q) - должно быть while (q->next)"
        ]
    },
    {
        "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов(1,3,5,2,4), (1,3,5,2,4), (1,2,3,5,4), (1,2,3,4,5)",
        "multiple": false,
        "options": [
            "Простой вставки",
            "Простого выбора",
            "Пирамидальная",
            "Простого обмена"
        ],
        "correctAnswers": [
            "Простой вставки"
        ]
    },
    {
        "question": "Прямой доступ к элементу данных в памяти делает возможным:",
        "multiple": false,
        "options": [
            "порядковый номер элемента в структуре",
            "идентификатор элемента в программе",
            "любая списочная структура",
            "адрес элемента в ОЗУ"
        ],
        "correctAnswers": [
            "адрес элемента в ОЗУ"
        ]
    },
    {
        "question": "Какая структура данных используется для хранения элементов данных в хеш-таблице, при реализации разрешения коллизий по методу цепочек (цепного хеширования)?",
        "multiple": false,
        "options": [
            "Дек",
            "Однонаправленный список",
            "Двоичное дерево",
            "Очередь"
        ],
        "correctAnswers": [
            "Однонаправленный список"
        ]
    },
    {
        "question": "Исходный текст \"abcdabcdaaacc\" был сжат, в результате был получен код abcd(4,4)(8,1)(1,1)(1,1)(5,1). Какой принцип сжатия текстовой информации при этом использовался?",
        "multiple": false,
        "options": [
            "уменьшение объема текста за счет формирования словаря кодов цепочек и замены цепочек на код",
            "частотное кодирование",
            "уменьшение объема текста за счет замены каждой повторно встреченной цепочки символов комбинацией: (количество знаков в цепочке, цепочка символов)",
            "уменьшение объема текста за счет замены повторно встретившейся цепочки символов ссылкой на ранее встреченную цепочку"
        ],
        "correctAnswers": [
            "уменьшение объема текста за счет замены повторно встретившейся цепочки символов ссылкой на ранее встреченную цепочку"
        ]
    },
    {
        "question": "Какая проблема может возникнуть в хеш-таблице с открытым адресом, после удаления ключа из первичного кластера ключей, хешированных с одним индексом?",
        "multiple": false,
        "options": [
            "Невозможность найти ключ в первичном кластере",
            "Ключи поменяют индексы, с которыми были хешированы при вставке в таблицу",
            "Неоднозначность результата поиска ключа",
            "Невозможно вставить ключ в первичный кластер"
        ],
        "correctAnswers": [
            "Невозможность найти ключ в первичном кластере"
        ]
    },
    {
        "question": "Что делает следующая функция?int trinity (int a, int b, int c) {   if ((a >= b) && (c<b)) return b;   else if (a >= b) return trinity (a,c,b);   else return trinity (b,a,c);}",
        "multiple": false,
        "options": [
            "ничего из перечисленного",
            "вычисляет минимальное значение",
            "вычисляет максимальное значение",
            "вычисляет среднее значение"
        ],
        "correctAnswers": [
            "вычисляет среднее значение"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в наихудшем случае:",
        "multiple": false,
        "options": [
            "f(n)=О(n^2)",
            "f(n)=О(log(n))",
            "f(n)=О(n log(n))",
            "f(n)=О(n^3)"
        ],
        "correctAnswers": [
            "f(n)=О(n^2)"
        ]
    },
    {
        "question": "Каков максимальный размер кодового слова, полученного алгоритмом Шеннона-Фано, для текста, частота появления символов в котором определяется таблицей: а-11,и-8,пробел - 6, л-4, п-3, с-3, м-2, ы-2, н-1, ш-1, ч-1, к-1, у-1, т-1, ь-1?",
        "multiple": false,
        "options": [
            "6",
            "5",
            "7",
            "4"
        ],
        "correctAnswers": [
            "6"
        ]
    },
    {
        "question": "Как называется определённая последовательность вычислительных шагов, преобразующих входные величины в выходные?",
        "multiple": false,
        "options": [
            "Множество допустимых операций над данными",
            "Алгоритм",
            "Структура данных",
            "Множество данных"
        ],
        "correctAnswers": [
            "Алгоритм"
        ]
    },
    {
        "question": "В АВЛ-дерево, содержащее ключи 8,10,11,14, был вставлен ключ 12. Потребовалась ли перестройка дерева и если да, то каким способом?",
        "multiple": false,
        "options": [
            "нет",
            "да, двойной LR",
            "да, одинарный правый",
            "да, двойной RL"
        ],
        "correctAnswers": [
            "да, двойной LR"
        ]
    },
    {
        "question": "Имеется указатель q на узел в середине линейного односвязного списка со следующей структурой узла:struct Tnode {    Tdata data;    Tnode* next;}Требуется вставить новый узел (узел содержит данные), ссылку на который хранит указатель qq, в позицию, в которой находится узел q. Какую последовательность операторов необходимо выполнить, чтобы корректно выполнилась данная операция вставки?",
        "multiple": false,
        "options": [
            "qq->next=q->next; q->next=qq; swap(qq->data, q->data);",
            "q->next=qq; qq->next=q; swap(qq->data,q->data);",
            "(*qq)=(*q);",
            "qq=q;"
        ],
        "correctAnswers": [
            "qq->next=q->next; q->next=qq; swap(qq->data, q->data);"
        ]
    },
    {
        "question": "Имеется двоичное дерево поиска, содержащее целые числа. Обратный обход дерева даёт следующий результат: 10, 30, 20, 50, 70, 60, 40. Какой узел является корнем дерева?",
        "multiple": false,
        "options": [
            "20",
            "30",
            "40",
            "10"
        ],
        "correctAnswers": [
            "40"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Шелла в наихудшем случае:",
        "multiple": false,
        "options": [
            "f(n)=О(n)",
            "f(n)=О(n log(n))",
            "f(n)=О(n^2)",
            "f(n)=О(log(n))"
        ],
        "correctAnswers": [
            "f(n)=О(n)"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в глубину на списке смежных вершин, если V – количество вершин в графе, а E –количество ребер:",
        "multiple": false,
        "options": [
            "f(n)=О(E)",
            "f(n)=О(V)",
            "f(n)=О(V^2)",
            "f(n)=О(log(E))"
        ],
        "correctAnswers": [
            "f(n)=О(V^2)"
        ]
    },
    {
        "question": "Маршрутом в графе называется:",
        "multiple": false,
        "options": [
            "последовательность вершин графа, в которой все вершины различны",
            "последовательность рёбер графа",
            "последовательность вершин графа, в которой каждая вершина соединена с предыдущей ребром",
            "последовательность вершин графа, в которой каждая вершина соединена с предыдущей ребром и все ребра различны"
        ],
        "correctAnswers": [
            "последовательность вершин графа, в которой каждая вершина соединена с предыдущей ребром и все ребра различны"
        ]
    },
    {
        "question": "Какие из приведённых строк кодаint fib(int n) {if (n < 2)    return 1;else { ... }}необходимо записать после else в рекурсивной функции вычисления n-ного числа Фибоначчи?",
        "multiple": false,
        "options": [
            "fib (n - 1) + fib (n - 2)",
            "return (n - 1) + (n - 2)",
            "return fib ((n - 1) + (n - 2))",
            "return fib (n - 1) + fib (n - 2)"
        ],
        "correctAnswers": [
            "return fib (n - 1) + fib (n - 2)"
        ]
    },
    {
        "question": "С какой вычислительной сложностью выполняются операции поиска, удаления и вставки в хеш-таблицах в лучшем случае?",
        "multiple": false,
        "options": [
            "O(1)",
            "O(n^2)",
            "O(n)",
            "O(n log n)"
        ],
        "correctAnswers": [
            "O(1)",
            "O(n)"
        ]
    },
    {
        "question": "Как называется алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе?",
        "multiple": false,
        "options": [
            "Алгоритм Белмана-Форда",
            "Алгоритм Флойда-Уоршала",
            "Алгоритм Дейкстры",
            "Алгоритм Крускала"
        ],
        "correctAnswers": [
            "Алгоритм Крускала"
        ]
    },
    {
        "question": "Структура хранения, в которой элементы данных физически размещаются в последовательных ячейках памяти строго один за другим:",
        "multiple": false,
        "options": [
            "векторная",
            "сетевая",
            "списочная",
            "иерархическая"
        ],
        "correctAnswers": [
            "векторная"
        ]
    },
    {
        "question": "Время выполнения рекурсивной функции f(n) в наихудшем случае определяется рекуррентным соотношениемЧто является решением этого соотношения?",
        "multiple": false,
        "options": [
            "O(n log2n)",
            "O(log2n)",
            "O(n)",
            "O(2n)"
        ],
        "correctAnswers": [
            "O(n log2n)"
        ]
    },
    {
        "question": "Какой из перечисленных алгоритмов реализует стратегию \"жадных алгоритмов\" (greedy algorithm)?",
        "multiple": false,
        "options": [
            "алгоритм Бойера-Мура",
            "алгоритм быстрой сортировки Quick-sort",
            "алгоритм Флойда",
            "алгоритм Дейкстры"
        ],
        "correctAnswers": [
            "алгоритм Дейкстры"
        ]
    },
    {
        "question": "Имеется идеально сбалансированное двоичное дерево, содержащее 31 узел. Сколько уровней в дереве?",
        "multiple": false,
        "options": [
            "4 уровня",
            "5 уровней",
            "7 уровней",
            "6 уровней"
        ],
        "correctAnswers": [
            "5 уровней"
        ]
    },
    {
        "question": "Алгоритм Прима - это:",
        "multiple": false,
        "options": [
            "Алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных",
            "Алгоритм поиска заданного пользователем количества путей между двумя вершинами во взвешенном графе",
            "Алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа",
            "Алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе"
        ],
        "correctAnswers": [
            "Алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе"
        ]
    },
    {
        "question": "Какие отношения между элементами неявно поддерживает структура данных массив:",
        "multiple": false,
        "options": [
            "Иерархические",
            "Наследование",
            "Линейные",
            "Нелинейные"
        ],
        "correctAnswers": [
            "Иерархические"
        ]
    },
    {
        "question": "Какой из приведенных кодов является префиксным (коды отдельных кодовых слов перечислены через запятую)?",
        "multiple": false,
        "options": [
            "0, 10, 11, 100, 110",
            "1, 12, 31",
            "0, 100, 101, 110, 111",
            "1, 10, 100, 1000"
        ],
        "correctAnswers": [
            "0, 100, 101, 110, 111"
        ]
    },
    {
        "question": "Чтобы алгоритм Дейкстры сформировал помимо длины кратчайшего пути от вершины а к вершине b и сам путь в графе, предусматривают запись вершин в линейную структуру. В какой последовательности расположатся вершины пути в структуре?",
        "multiple": false,
        "options": [
            "Последовательно от вершины a до b",
            "Последовательно от вершины b до a",
            "Упорядоченно по возрастанию значений вершин",
            "В любом порядке"
        ],
        "correctAnswers": [
            "Последовательно от вершины b до a"
        ]
    },
    {
        "question": "К графу на рисунке 1 применен алгоритм обхода в ширину. Какое из остовных деревьев соответствует этому алгоритму обхода с вершины 3?",
        "multiple": false,
        "options": [
            "5",
            "4",
            "3",
            "2"
        ],
        "correctAnswers": [
            "4"
        ]
    },
    {
        "question": "Структура хранения данных, в которой элементы явно хранят связи с соседними элементами структуры:",
        "multiple": false,
        "options": [
            "реляционная",
            "векторная",
            "списочная",
            "массив"
        ],
        "correctAnswers": [
            "списочная"
        ]
    },
    {
        "question": "Специфичным для обхода графа, в отличие от обхода дерева, является:",
        "multiple": false,
        "options": [
            "в графе могут быть циклы",
            "у дерева есть корень",
            "никакой специфики нет, т.к. дерево - частный случай графа",
            "в графе всегда только один маршрут до любого узла"
        ],
        "correctAnswers": [
            "у дерева есть корень"
        ]
    },
    {
        "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма Дейкстры в графе, построенном на матрице смежности, если V – количество вершин в графе, а E –количество ребер:",
        "multiple": false,
        "options": [
            "f(n)=О(V)",
            "f(n)=О(E)",
            "f(n)=О(V^2)",
            "f(n)=О(log(E))"
        ],
        "correctAnswers": [
            "f(n)=О(V^2)"
        ]
    },
    {
        "question": "Структура данных массив отображается на физическом уровне в структуру хранения:",
        "multiple": false,
        "options": [
            "список",
            "граф",
            "сеть",
            "вектор"
        ],
        "correctAnswers": [
            "вектор"
        ]
    },
    {
        "question": "Что необходимо делать с большим объемом информации, связанной с каждым ключом:",
        "multiple": false,
        "options": [
            "Чаще рехешировать",
            "Не хранить ее в хеш-таблице",
            "Увеличить хэш-таблицу",
            "Хранить ее в хеш-таблице"
        ],
        "correctAnswers": [
            "Увеличить хэш-таблицу"
        ]
    },
    {
        "question": "Из числа приведённых сортировок выберите наименее эффективную на больших массивах:",
        "multiple": false,
        "options": [
            "пирамидальная",
            "пузырьковая",
            "вставками",
            "выбором"
        ],
        "correctAnswers": [
            "пузырьковая"
        ]
    },
    {
        "question": "Какой вычислительной сложностью характеризуется алгоритм \"грубой силы\" (brute force attack) прямого поиска по образцу?",
        "multiple": false,
        "options": [
            "O(n log m)",
            "O(n*m)",
            "O(n^2)",
            "O(n+m)"
        ],
        "correctAnswers": [
            "O(n+m)"
        ]
    }
];